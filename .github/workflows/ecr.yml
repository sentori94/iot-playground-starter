name: Build & Push to ECR

on:
  workflow_dispatch:
    inputs:
      run_sonar:
        description: 'Exécuter analyse SonarQube'
        required: false
        type: boolean
        default: true

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # SonarQube a besoin de tout l'historique pour calculer correctement l'info de blame

      - uses: actions/setup-java@v4
        with:
            distribution: temurin
            java-version: '17'
            cache: maven

      # Build complet (tests + jacoco) pour alimenter Sonar
      - name: Build avec tests (Jacoco)
        run: mvn -B clean verify

      # Scan SonarQube (Self-hosted ou SonarCloud suivant vos vars/secrets)
      - name: SonarQube Scan
        if: ${{ inputs.run_sonar }}
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          mvn -B sonar:sonar \
            -Dsonar.projectKey=${{ vars.SONAR_PROJECT_KEY }} \
            -Dsonar.organization=${{ vars.SONAR_ORGANIZATION }} \
            -Dsonar.host.url=${{ vars.SONAR_HOST_URL }} \
            -Dsonar.login=$SONAR_TOKEN \
            -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml

      # Vérifier que le rapport a été généré
      - name: Vérifier rapport SonarQube
        if: ${{ inputs.run_sonar }}
        run: |
          if [ -f "target/sonar/report-task.txt" ]; then
            echo "Rapport trouvé dans target/sonar/report-task.txt"
            cat target/sonar/report-task.txt
            # Créer le répertoire .scannerwork et copier le fichier
            mkdir -p .scannerwork
            cp target/sonar/report-task.txt .scannerwork/report-task.txt
            echo "Fichier copié vers .scannerwork/report-task.txt"
          elif [ -f ".scannerwork/report-task.txt" ]; then
            echo "Rapport trouvé dans .scannerwork/report-task.txt"
            cat .scannerwork/report-task.txt
          else
            echo "Aucun rapport trouvé"
            find . -name "report-task.txt" 2>/dev/null || echo "Fichier report-task.txt introuvable"
          fi

      # Quality Gate (attend le traitement asynchrone côté Sonar)
      - name: SonarQube Quality Gate
        if: ${{ inputs.run_sonar }}
        id: quality_gate
        uses: sonarsource/sonarqube-quality-gate-action@v1.1.0
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        timeout-minutes: 5

      - name: Afficher le statut du Quality Gate
        if: ${{ inputs.run_sonar && always() }}
        run: |
          echo "Quality Gate outcome: ${{ steps.quality_gate.outcome }}"
          echo "Quality Gate status: ${{ steps.quality_gate.outputs.quality-gate-status }}"

      - name: Échec si Quality Gate KO
        if: ${{ inputs.run_sonar && steps.quality_gate.outcome == 'success' && steps.quality_gate.outputs.quality-gate-status != 'PASSED' }}
        run: |
          echo "❌ Quality Gate a échoué avec le statut: ${{ steps.quality_gate.outputs.quality-gate-status }}"
          exit 1

      - name: Upload rapports tests & couverture (artefact)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-and-coverage-reports
          path: |
            target/site/jacoco/*
            target/surefire-reports/*

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Login to ECR (explicit)
        run: |
          aws ecr get-login-password --region ${{ vars.AWS_REGION }} \
            | docker login --username AWS --password-stdin ${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com

      - name: Build & push Docker image (tag latest)
        run: |
          IMAGE="${{ vars.AWS_ACCOUNT_ID }}.dkr.ecr.${{ vars.AWS_REGION }}.amazonaws.com/${{ vars.ECR_REPOSITORY }}:latest"
          docker build -t "$IMAGE" .
          docker push "$IMAGE"
